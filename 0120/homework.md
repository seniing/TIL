#### 1. 이름 공간(Namespace)

- Python에서 변수를 찾을 때 접근하는 이름 공간을 순서대로 작성하시오.

  ```
  <LEGB Rule>
  - Local scope(지역 스코프) : 함수가 만든 스코프로 함수 내부에서만 참조할 수 있는 공간
  - Enclosed scope : 특정 함수의 상위 함수
  - Global scope(전역 스코프) : 함수 밖의 변수 혹은 import된 모듈
  							코드 어디에서든 참조할 수 있는 공간
  - Built-in scope : 파이썬 안에 내장되어 있는 함수 또는 속성
  ```

  



#### 2. 매개변수와 인자, 그리고 변환

- 아래의 보기 (1)  ~ (4) 중에서, 옳지 않은 것을 고르시오.

  ```
  (1) 함수는 오직 하나의 객체만 반환할 수 있으므로 'return a, b'와 같이 쓸 수 없다.
  	-> 'return a, b' == 'return (a, b)'
  (2) 함수에서 return을 작성하지 않으면 None 값을 반환한다.
  (3) 함수의 매개변수(parameter)는 함수를 선언할 때 설정한 값이며, 전달 인자(argument)는 함수를 호출할 때 넘겨주는 값이다.
  (4) 가변 인자를 설정할 때는 함수 선언 시 매개변수 앞에 * 을 붙이고, 이 때는 함수내에서 tuple로 처리된다.
  ```
  
  

#### 3. 재귀 함수

- 재귀 함수를 사용했을 때 얻을 수 있는 장점과 단점을 반복문과 비교하여 작성하시오.

  ```
  < 장점 >
  - 알고리즘 구현시 많이 사용한다.
  - 코드가 더 직관적이고 이해하기 쉬운 경우가 있다.
  - 변수 사용을 줄여준다.
  
  < 단점 >
  - 메모리 스택이 넘치거나(Stack overflow) 프로그램 실행 속도가 늘어지는 단점이 생깁니다.
  - 파이썬에서는 이를 방지하기 위해 1,000번이 넘어가게 되면 더이상 함수를 호출하지 않고, 종료됩니다. (최대 재귀 깊이)
  ```

  

  <피보나치 수열>

  - 재귀함수

    ```
    def fib(n):
        if n < 2:
            return n
        else:
            return fib(n-1) + fib(n-2)
    ```

  - 반복문

    ```
    def fib_loop(n):
        if n < 2:
            return n
        lst = [0, 1]
        for i in range(2, n+1):
            lst.append(lst[i-1] + lst[i-2])
        return lst[-1]
    ```

  - 재귀함수와 반복문의 연산 속도 차이 

    : **재귀함수**에 **35**를 넣었을 때 연산 시간 1 초과, 

    : **반복문**에 **10000**을 넣었을 때는 연산 시간 1 미만. 

    ***-> 변수 값이 커질수록 재귀함수의 연산 시간이 훨씬 길다!***

    ```
    import time
    
    t0 = time.time()
    fib(35)
    t1 = time.time()
    
    total = t1 - t0
    print(total) #=> 1.8418912887573242
    ```

    ```
    import time
    
    t0 = time.time()
    fib_loop(10000)
    t1 = time.time()
    
    total = t1 - t0
    print(total) #=> 0.005004167556762695
    ```

    